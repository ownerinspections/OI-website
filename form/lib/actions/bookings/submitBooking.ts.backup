"use server";

import { getRequest, patchRequest, postRequest } from "@/lib/http/fetcher";
import { createContact } from "@/lib/actions/contacts/createContact";
import { updateContact } from "@/lib/actions/contacts/updateContact";
import { redirect } from "next/navigation";

export type BookingActionResult = {
	success?: boolean;
	errors?: Record<string, string>;
	message?: string;
	debug?: unknown[];
};

type ContactData = {
	first_name?: string;
	last_name?: string;
	phone?: string;
	email?: string;
	contact_type?: string;
};

function validateContact(contact: ContactData, index: string | number, isNew: boolean = false): Record<string, string> {
	const errors: Record<string, string> = {};
	
	// Validate phone - always required for real estate agents
	if (contact.contact_type === "real_estate_agent") {
		if (!contact.phone?.trim()) {
			errors[`contact_${index}_phone`] = "Phone is required for real estate agents";
		}
	} else if (isNew && contact.first_name && contact.last_name && !contact.phone?.trim()) {
		// For non-real estate agents, only validate phone if it's a new contact with name data
		errors[`contact_${index}_phone`] = "Phone is required";
	}
	
	return errors;
}

export async function submitBooking(prevState: BookingActionResult, formData: FormData): Promise<BookingActionResult> {
	const debug: unknown[] = [];
	
	try {
		console.log("üöÄ [SUBMIT BOOKING] Starting booking submission");
		debug.push({ tag: "start", timestamp: new Date().toISOString() });
		
		const bookingId = String(formData.get("booking_id") ?? "");
		const userId = String(formData.get("user_id") ?? "");
		const propertyId = String(formData.get("property_id") ?? "");
		const contactId = String(formData.get("contact_id") ?? "");
		const dealId = String(formData.get("deal_id") ?? "");
		const quoteId = String(formData.get("quote_id") ?? "");
		const invoiceId = String(formData.get("invoice_id") ?? "");
		const inspectionType = String(formData.get("inspection_type") ?? "");
		
		console.log("üöÄ [SUBMIT BOOKING] Form data keys:", Array.from(formData.keys()));
		debug.push({ 
			tag: "form_data", 
			bookingId, 
			userId, 
			propertyId, 
			contactId, 
			dealId, 
			quoteId, 
			invoiceId,
			inspectionType
		});
		
		// Debug: Log all form data entries for contact person fields
		console.log("üîç [SUBMIT BOOKING] All form data entries:");
		for (const [key, value] of formData.entries()) {
			if (key.includes("contact_person") || key.includes("property_") || key.includes("contact_")) {
				console.log(`  ${key}: ${value}`);
			}
		}
		
		if (!bookingId) {
			return {
				success: false,
				message: "Booking ID is required",
				debug
			};
		}
		
		// Load existing contacts and booking
		const bookingRes = await getRequest<{ data: any }>(`/items/bookings/${encodeURIComponent(bookingId)}?fields=*`);
		const booking = (bookingRes as any)?.data ?? null;
		
		// Load contacts from os_deals_contacts junction table
		const contactsList: any[] = [];
		if (dealId) {
			try {
				const contactsRes = await getRequest<{ data: Array<{ contacts_id: any }> }>(
					`/items/os_deals_contacts?filter[os_deals_id][_eq]=${encodeURIComponent(String(dealId))}&fields=contacts_id.id,contacts_id.first_name,contacts_id.last_name,contacts_id.phone,contacts_id.email,contacts_id.contact_type&limit=100`
				);
				const contactsExpanded: any[] = Array.isArray((contactsRes as any)?.data) ? (contactsRes as any).data.map((r: any) => r.contacts_id) : [];
				
				// Normalize contacts list
				for (const contact of contactsExpanded) {
					if (typeof contact === "object" && contact) {
						contactsList.push({
							id: contact.id,
							first_name: contact.first_name,
							last_name: contact.last_name,
							phone: contact.phone,
							email: contact.email,
							contact_type: contact.contact_type
						});
					}
				}
			} catch (error) {
				console.error(`Failed to load contacts from os_deals_contacts for deal ${dealId}:`, error);
			}
		}
		
		debug.push({ 
			tag: "loaded_data", 
			contactsCount: contactsList.length 
		});
		
		// Validate existing contacts
		const allErrors: Record<string, string> = {};
		for (const ct of contactsList) {
			const fn = formData.get(`contact_${ct.id}_first_name`);
			const ln = formData.get(`contact_${ct.id}_last_name`);
			const ph = formData.get(`contact_${ct.id}_phone`);
			const em = formData.get(`contact_${ct.id}_email`);
			const contactType = formData.get(`contact_${ct.id}_contact_type`);
			
			const contactData: ContactData = {
				first_name: typeof fn === "string" ? fn : undefined,
				last_name: typeof ln === "string" ? ln : undefined,
				phone: typeof ph === "string" ? ph : undefined,
				email: typeof em === "string" ? em : undefined,
				contact_type: typeof contactType === "string" ? contactType : undefined,
			};
			
			console.log(`üîç [SUBMIT BOOKING] Validating contact ${ct.id}:`, {
				contactType: contactData.contact_type,
				phone: contactData.phone,
				isRealEstateAgent: contactData.contact_type === "real_estate_agent"
			});
			
			const contactErrors = validateContact(contactData, ct.id, false); // false = existing contact (but now editable)
			if (Object.keys(contactErrors).length > 0) {
				console.log(`‚ùå [SUBMIT BOOKING] Contact ${ct.id} validation errors:`, contactErrors);
			}
			Object.assign(allErrors, contactErrors);
		}
		
		// Validate contact person for all inspections
		// Handle property-specific contact person choices
		if (inspectionType) {
			// Get all property-specific contact person choices
			const contactPersonChoices: Record<string, string> = {};
			for (const [key, value] of formData.entries()) {
				if (key.includes("_contact_person_choice")) {
					contactPersonChoices[key] = String(value);
				}
			}
			
			// Validate each property's contact person choice
			for (const [fieldName, choice] of Object.entries(contactPersonChoices)) {
				if (choice === "new_contact") {
					const propertyId = fieldName.match(/property_(\d+)_contact_person_choice/)?.[1];
					if (propertyId) {
						const contactPersonData = {
							first_name: String(formData.get(`property_${propertyId}_contact_person_first_name`) ?? "").trim(),
							last_name: String(formData.get(`property_${propertyId}_contact_person_last_name`) ?? "").trim(),
							email: String(formData.get(`property_${propertyId}_contact_person_email`) ?? "").trim(),
							phone: String(formData.get(`property_${propertyId}_contact_person_phone`) ?? "").trim(),
							contact_type: String(formData.get(`property_${propertyId}_contact_person_contact_type`) ?? "").trim()
						};
						
						if (!contactPersonData.first_name) {
							allErrors[`property_${propertyId}_contact_person_first_name`] = "First name is required for contact person";
						}
						if (!contactPersonData.last_name) {
							allErrors[`property_${propertyId}_contact_person_last_name`] = "Last name is required for contact person";
						}
						if (!contactPersonData.email && contactPersonData.contact_type !== "real_estate_agent") {
							allErrors[`property_${propertyId}_contact_person_email`] = "Email is required for contact person";
						}
						if (!contactPersonData.phone) {
							if (contactPersonData.contact_type === "real_estate_agent") {
								allErrors[`property_${propertyId}_contact_person_phone`] = "Phone is required for real estate agents";
							} else {
								allErrors[`property_${propertyId}_contact_person_phone`] = "Phone is required for contact person";
							}
						}
						if (!contactPersonData.contact_type) {
							allErrors[`property_${propertyId}_contact_person_contact_type`] = "Contact type is required for contact person";
						}
					}
				}
			}
		}
		
		// Validate new contacts
		let validateContactIndex = 1;
		let foundAnyNewContactsForValidation = false;
		while (true) {
			const firstName = String(formData.get(`new_contact_${validateContactIndex}_first_name`) ?? "").trim();
			const lastName = String(formData.get(`new_contact_${validateContactIndex}_last_name`) ?? "").trim();
			const phone = String(formData.get(`new_contact_${validateContactIndex}_phone`) ?? "").trim();
			const email = String(formData.get(`new_contact_${validateContactIndex}_email`) ?? "").trim();
			const contactType = String(formData.get(`new_contact_${validateContactIndex}_contact_type`) ?? "").trim();
			
			if (!firstName && !lastName && !phone && !email && !contactType) {
				// If we haven't found any new contacts yet, continue checking higher indices
				// If we have found contacts before, then we've reached the end
				if (!foundAnyNewContactsForValidation && validateContactIndex < 10) {
					validateContactIndex++;
					continue;
				} else {
					break;
				}
			}
			
			foundAnyNewContactsForValidation = true;
			const contactData: ContactData = { first_name: firstName, last_name: lastName, phone, email, contact_type: contactType };
			const contactErrors = validateContact(contactData, `new_${validateContactIndex}`, true); // true = new contact (editable phone)
			Object.assign(allErrors, contactErrors);
			
			validateContactIndex++;
		}
		
		// If there are validation errors, return them
		if (Object.keys(allErrors).length > 0) {
			console.log("‚ùå [SUBMIT BOOKING] Validation errors:", allErrors);
			debug.push({ tag: "validation_errors", errors: allErrors });
			return {
				success: false,
				errors: allErrors,
				debug
			};
		}
		
		// If validation passes, proceed with the original booking logic
		console.log("‚úÖ [SUBMIT BOOKING] Validation passed, proceeding with booking");
		debug.push({ tag: "validation_passed" });
		
		
		// Execute the original booking logic here
		const updates: Array<Promise<any>> = [];
		
		// Handle existing contacts updates
		console.log("üîß [SUBMIT BOOKING] Processing existing contacts:", contactsList.length);
		for (const ct of contactsList) {
			const fn = formData.get(`contact_${ct.id}_first_name`);
			const ln = formData.get(`contact_${ct.id}_last_name`);
			const ph = formData.get(`contact_${ct.id}_phone`);
			const em = formData.get(`contact_${ct.id}_email`);
			const contactType = formData.get(`contact_${ct.id}_contact_type`);
			
			const payload: Record<string, unknown> = {};
			if (typeof fn === "string") payload.first_name = fn;
			if (typeof ln === "string") payload.last_name = ln;
			if (typeof ph === "string") payload.phone = ph;
			if (typeof em === "string" && em.trim()) payload.email = em.trim();
			if (typeof contactType === "string" && contactType.trim()) payload.contact_type = contactType.trim();
			if (Object.keys(payload).length > 0) {
				console.log(`üîß [SUBMIT BOOKING] Updating contact ${ct.id} with payload:`, payload);
				updates.push(patchRequest(`/items/contacts/${encodeURIComponent(String(ct.id))}`, payload));
			}
		}
		
		// Handle contact person for all inspections (except dilapidation which has its own logic)
		let contactPersonId: string | number | undefined = undefined;
		
		if (inspectionType && inspectionType !== "dilapidation") {
			// Get all property-specific contact person choices
			const contactPersonChoices: Record<string, string> = {};
			for (const [key, value] of formData.entries()) {
				if (key.includes("_contact_person_choice")) {
					contactPersonChoices[key] = String(value);
				}
			}
			
			console.log("üîç [SUBMIT BOOKING] Found contact person choices:", contactPersonChoices);
			
			if (Object.keys(contactPersonChoices).length === 0) {
				console.log("‚ö†Ô∏è [SUBMIT BOOKING] No contact person choices found in form data");
				// Don't set a fallback - let the system handle this case
				console.log("‚ö†Ô∏è [SUBMIT BOOKING] No contact person will be set for this deal");
			}
			
			// Process each property's contact person choice
			for (const [fieldName, choice] of Object.entries(contactPersonChoices)) {
				const propertyId = fieldName.match(/property_(\d+)_contact_person_choice/)?.[1];
				if (!propertyId) continue;
				
				if (choice === "new_contact") {
					// Create new contact person for this property
					const contactPersonData = {
						first_name: String(formData.get(`property_${propertyId}_contact_person_first_name`) ?? "").trim(),
						last_name: String(formData.get(`property_${propertyId}_contact_person_last_name`) ?? "").trim(),
						email: String(formData.get(`property_${propertyId}_contact_person_email`) ?? "").trim(),
						phone: String(formData.get(`property_${propertyId}_contact_person_phone`) ?? "").trim(),
						contact_type: String(formData.get(`property_${propertyId}_contact_person_contact_type`) ?? "").trim()
					};
					
					console.log(`üîç [SUBMIT BOOKING] Contact person data for property ${propertyId}:`, contactPersonData);
					
					if (contactPersonData.first_name && contactPersonData.last_name && (contactPersonData.email || contactPersonData.contact_type === "real_estate_agent")) {
						console.log(`üÜï [SUBMIT BOOKING] Creating contact person for property ${propertyId}`);
						try {
							const contactPersonInput: any = {
								first_name: contactPersonData.first_name,
								last_name: contactPersonData.last_name,
								email: contactPersonData.email || "",
								phone: contactPersonData.phone || "",
								contact_type: contactPersonData.contact_type || "individual"
							};
							
							console.log(`üîç [SUBMIT BOOKING] Contact person input:`, contactPersonInput);
							
							const res = await createContact(contactPersonInput);
							console.log(`üîç [SUBMIT BOOKING] Create contact response:`, res);
							
							if (res?.success && res?.contactId) {
								contactPersonId = res.contactId;
								console.log(`‚úÖ [SUBMIT BOOKING] Created contact person with ID: ${contactPersonId}`);
								
								// Link contact person to current user
								if (userId) {
									try {
										await updateContact(contactPersonId, { user: userId } as any);
										console.log(`‚úÖ [SUBMIT BOOKING] Successfully linked contact person ${contactPersonId} to user ${userId}`);
									} catch (linkError) {
										console.error(`‚ùå [SUBMIT BOOKING] Failed to link contact person ${contactPersonId} to user ${userId}:`, linkError);
									}
								}
								
								// Link contact person to deal via os_deals_contacts junction table
								if (dealId) {
									try {
										await postRequest("/items/os_deals_contacts", {
											os_deals_id: String(dealId),
											contacts_id: String(contactPersonId)
										} as unknown as Record<string, unknown>);
										console.log(`‚úÖ [SUBMIT BOOKING] Successfully linked contact person ${contactPersonId} to deal ${dealId} via os_deals_contacts`);
									} catch (junctionError) {
										console.error(`‚ùå [SUBMIT BOOKING] Failed to link contact person ${contactPersonId} to deal ${dealId} via os_deals_contacts:`, junctionError);
									}
								}
							} else {
								console.error(`‚ùå [SUBMIT BOOKING] Failed to create contact person - invalid response:`, res);
							}
						} catch (error) {
							console.error(`‚ùå [SUBMIT BOOKING] Failed to create contact person for property ${propertyId}:`, error);
						}
					} else {
						console.log(`‚ö†Ô∏è [SUBMIT BOOKING] Missing required fields for contact person - first_name: ${contactPersonData.first_name}, last_name: ${contactPersonData.last_name}, email: ${contactPersonData.email}`);
					}
				} else if (choice === "me") {
					// Use the current contact as contact person
					contactPersonId = contactId;
					console.log(`‚úÖ [SUBMIT BOOKING] Using current contact ${contactId} as contact person for property ${propertyId}`);
				}
				
				// Continue processing other properties - don't break here
			}
			
			// If no contact person choices were found, default to using the main contact
			if (Object.keys(contactPersonChoices).length === 0 && contactId) {
				contactPersonId = contactId;
				console.log(`‚úÖ [SUBMIT BOOKING] No contact person choices found, defaulting to main contact ${contactId} as contact person`);
			}
		}
		
		// Handle new contacts creation
		let newContactIds: Array<string | number> = [];
		const newContacts: Array<{ first_name?: string; last_name?: string; phone?: string; email?: string; contact_type?: string }> = [];
		let createContactIndex = 1;
		let foundAnyNewContacts = false;
		while (true) {
			const firstName = String(formData.get(`new_contact_${createContactIndex}_first_name`) ?? "").trim();
			const lastName = String(formData.get(`new_contact_${createContactIndex}_last_name`) ?? "").trim();
			const phone = String(formData.get(`new_contact_${createContactIndex}_phone`) ?? "").trim();
			const email = String(formData.get(`new_contact_${createContactIndex}_email`) ?? "").trim();
			const contactType = String(formData.get(`new_contact_${createContactIndex}_contact_type`) ?? "").trim();
			
			if (!firstName && !lastName && !phone && !email && !contactType) {
				// If we haven't found any new contacts yet, continue checking higher indices
				// If we have found contacts before, then we've reached the end
				if (!foundAnyNewContacts && createContactIndex < 10) {
					createContactIndex++;
					continue;
				} else {
					break;
				}
			}
			
			foundAnyNewContacts = true;
			newContacts.push({
				first_name: firstName || undefined,
				last_name: lastName || undefined,
				phone: phone || undefined,
				email: email || undefined,
				contact_type: contactType || undefined
			});
			createContactIndex++;
		}
		
		if (newContacts.length > 0) {
			console.log(`üÜï [SUBMIT BOOKING] Creating ${newContacts.length} new contacts`);
			try {
				for (const contactData of newContacts) {
					if (contactData.first_name && contactData.last_name && (contactData.email || contactData.contact_type === "real_estate_agent")) {
						const contactInput: any = {
							first_name: contactData.first_name,
							last_name: contactData.last_name,
							email: contactData.email || "",
							phone: contactData.phone || ""
						};
						
						// Add contact_type if provided
						if (contactData.contact_type) {
							contactInput.contact_type = contactData.contact_type;
						}
						
						const res = await createContact(contactInput);
						if (res?.success && res?.contactId) {
							newContactIds.push(res.contactId);
							
							// Link contact to current user
							if (userId) {
								try {
									await updateContact(res.contactId, { user: userId } as any);
									console.log(`‚úÖ [SUBMIT BOOKING] Successfully linked contact ${res.contactId} to user ${userId}`);
								} catch (linkError) {
									console.error(`‚ùå [SUBMIT BOOKING] Failed to link contact ${res.contactId} to user ${userId}:`, linkError);
								}
							} else {
								console.warn(`‚ö†Ô∏è [SUBMIT BOOKING] No userId provided, contact ${res.contactId} not linked to user`);
							}
							
							// Link contact to deal via os_deals_contacts junction table
							if (dealId) {
								try {
									await postRequest("/items/os_deals_contacts", {
										os_deals_id: String(dealId),
										contacts_id: String(res.contactId)
									} as unknown as Record<string, unknown>);
									console.log(`‚úÖ [SUBMIT BOOKING] Successfully linked contact ${res.contactId} to deal ${dealId} via os_deals_contacts`);
								} catch (junctionError) {
									console.error(`‚ùå [SUBMIT BOOKING] Failed to link contact ${res.contactId} to deal ${dealId} via os_deals_contacts:`, junctionError);
								}
							} else {
								console.warn(`‚ö†Ô∏è [SUBMIT BOOKING] No dealId provided, contact ${res.contactId} not linked to deal`);
							}
						}
					}
				}
				console.log(`‚úÖ [SUBMIT BOOKING] Successfully created contacts with IDs:`, newContactIds);
			} catch (error) {
				console.error("‚ùå [SUBMIT BOOKING] Failed to create new contacts:", error);
			}
		}
		
		// Add new contacts to the booking's contacts array
		if (newContactIds.length > 0 && booking?.id != null) {
			console.log(`üîó [SUBMIT BOOKING] Adding ${newContactIds.length} new contacts to booking ${booking.id}`);
			try {
				// Get existing contact IDs from booking
				const existingContactIds: string[] = [];
				if (Array.isArray(booking?.contacts)) {
					for (const c of booking.contacts) {
						const id = typeof c === "object" ? String((c as any)?.id ?? "") : String(c ?? "");
						if (id) existingContactIds.push(id);
					}
				}
				
				// Combine existing and new contact IDs
				const allContactIds = [...existingContactIds, ...newContactIds.map(String)];
				
				console.log(`üîó [SUBMIT BOOKING] Existing contacts: [${existingContactIds.join(', ')}]`);
				console.log(`üîó [SUBMIT BOOKING] New contacts: [${newContactIds.map(String).join(', ')}]`);
				console.log(`üîó [SUBMIT BOOKING] All contacts: [${allContactIds.join(', ')}]`);
				
				// Update booking with combined contacts
				await patchRequest(`/items/bookings/${encodeURIComponent(String(booking.id))}`, {
					contacts: allContactIds
				});
				console.log(`‚úÖ [SUBMIT BOOKING] Successfully added new contacts to booking ${booking.id}`);
			} catch (error) {
				console.error("‚ùå [SUBMIT BOOKING] Failed to add new contacts to booking:", error);
			}
		}
		
		if (updates.length > 0) {
			console.log(`üîß [SUBMIT BOOKING] Processing ${updates.length} updates for existing records`);
			await Promise.allSettled(updates);
			console.log(`‚úÖ [SUBMIT BOOKING] Completed all updates`);
		}
		
		// Update booking status and contacts
		if (booking?.id != null) {
			const tentativeDate = String(formData.get("booking_tentative_inspection_date") ?? "").trim();
			const additionalInfo = String(formData.get("booking_additional_information") ?? "").trim();
			const applicationProcess = String(formData.get("booking_application_process") ?? "").trim();
			
			const bookingPayload: Record<string, unknown> = { status: "booked" };
			if (tentativeDate) bookingPayload.tentative_date = tentativeDate;
			if (additionalInfo) bookingPayload.additional_info = additionalInfo;
			if (inspectionType) bookingPayload.inspection_type = inspectionType;
			if (applicationProcess) bookingPayload.application_process = applicationProcess;
			
			// Collect all contact IDs for the booking (existing + new + contact person)
			const allContactIds: Array<string | number> = [];
			
			// Add existing contacts
			for (const ct of contactsList) {
				allContactIds.push(ct.id);
			}
			
			// Add new contacts
			allContactIds.push(...newContactIds);
			
			// Add contact person for all inspections (if not already included)
			if (contactPersonId) {
				const contactPersonIdStr = String(contactPersonId);
				if (!allContactIds.some(id => String(id) === contactPersonIdStr)) {
					allContactIds.push(contactPersonId);
					console.log(`üìù [SUBMIT BOOKING] Adding contact_person ${contactPersonId} to booking contacts array`);
				}
			}
			
			// Set contacts array on booking
			if (allContactIds.length > 0) {
				bookingPayload.contacts = allContactIds;
				console.log(`üìù [SUBMIT BOOKING] Setting booking contacts array with ${allContactIds.length} contacts:`, allContactIds);
			}
			
			console.log(`üìù [SUBMIT BOOKING] Updating booking ${booking.id} with payload:`, bookingPayload);
			await patchRequest(`/items/bookings/${encodeURIComponent(String(booking.id))}`, bookingPayload);
			console.log(`‚úÖ [SUBMIT BOOKING] Successfully updated booking status to 'booked'`);
		}
		
		// Update deal with contact_person and price for all inspections
		if (dealId) {
			const dealUpdateData: Record<string, unknown> = {};
			
			// Handle contact person updates based on inspection type
			if (inspectionType === "dilapidation") {
				console.log(`üîç [SUBMIT BOOKING] Processing dilapidation contact person updates for deal ${dealId}`);
				// For dilapidation, update contact_person, contact_person2, etc. based on property order
				const contactPersonChoices: Record<string, string> = {};
				for (const [key, value] of formData.entries()) {
					if (key.includes("_contact_person_choice")) {
						contactPersonChoices[key] = String(value);
					}
				}
				console.log(`üîç [SUBMIT BOOKING] Found contact person choices:`, contactPersonChoices);
				
				// Get properties in order to determine which contact_person field to update
				let propertiesInOrder: string[] = [];
				try {
					const dealRes = await getRequest<{ data: any }>(`/items/os_deals/${encodeURIComponent(String(dealId))}?fields=properties,properties2,properties3,properties4`);
					const deal = (dealRes as any)?.data;
					
					// Collect property IDs in order
					if (deal?.properties && Array.isArray(deal.properties)) {
						propertiesInOrder.push(...deal.properties.map((id: any) => String(id)));
					}
					if (deal?.properties2 && Array.isArray(deal.properties2)) {
						propertiesInOrder.push(...deal.properties2.map((id: any) => String(id)));
					}
					if (deal?.properties3 && Array.isArray(deal.properties3)) {
						propertiesInOrder.push(...deal.properties3.map((id: any) => String(id)));
					}
					if (deal?.properties4 && Array.isArray(deal.properties4)) {
						propertiesInOrder.push(...deal.properties4.map((id: any) => String(id)));
					}
					
					console.log(`üîç [SUBMIT BOOKING] Properties in order for deal ${dealId}:`, propertiesInOrder);
				} catch (error) {
					console.error(`‚ùå [SUBMIT BOOKING] Failed to load properties for deal ${dealId}:`, error);
				}
				
				// Process each property's contact person choice
				for (const [fieldName, choice] of Object.entries(contactPersonChoices)) {
					const propertyId = fieldName.match(/property_(\d+)_contact_person_choice/)?.[1];
					if (!propertyId) continue;
					
					// Find the index of this property in the ordered list
					const propertyIndex = propertiesInOrder.indexOf(propertyId);
					if (propertyIndex === -1) {
						console.warn(`‚ö†Ô∏è [SUBMIT BOOKING] Property ${propertyId} not found in deal properties list`);
						continue;
					}
					
					let propertyContactPersonId: string | number | undefined = undefined;
					
					if (choice === "new_contact") {
						// Create new contact person for this property
						const contactPersonData = {
							first_name: String(formData.get(`property_${propertyId}_contact_person_first_name`) ?? "").trim(),
							last_name: String(formData.get(`property_${propertyId}_contact_person_last_name`) ?? "").trim(),
							email: String(formData.get(`property_${propertyId}_contact_person_email`) ?? "").trim(),
							phone: String(formData.get(`property_${propertyId}_contact_person_phone`) ?? "").trim(),
							contact_type: String(formData.get(`property_${propertyId}_contact_person_contact_type`) ?? "").trim()
						};
						
						if (contactPersonData.first_name && contactPersonData.last_name && (contactPersonData.email || contactPersonData.contact_type === "real_estate_agent")) {
							try {
								const contactPersonInput: any = {
									first_name: contactPersonData.first_name,
									last_name: contactPersonData.last_name,
									email: contactPersonData.email || "",
									phone: contactPersonData.phone || "",
									contact_type: contactPersonData.contact_type || "individual"
								};
								
								const res = await createContact(contactPersonInput);
								if (res?.success && res?.contactId) {
									propertyContactPersonId = res.contactId;
									
									// Link contact person to current user
									if (userId) {
										try {
											await updateContact(propertyContactPersonId, { user: userId } as any);
										} catch (linkError) {
											console.error(`‚ùå [SUBMIT BOOKING] Failed to link contact person ${propertyContactPersonId} to user ${userId}:`, linkError);
										}
									}
									
									// Link contact person to deal via os_deals_contacts junction table
									try {
										await postRequest("/items/os_deals_contacts", {
											os_deals_id: String(dealId),
											contacts_id: String(propertyContactPersonId)
										} as unknown as Record<string, unknown>);
									} catch (junctionError) {
										console.error(`‚ùå [SUBMIT BOOKING] Failed to link contact person ${propertyContactPersonId} to deal ${dealId} via os_deals_contacts:`, junctionError);
									}
								}
							} catch (error) {
								console.error(`‚ùå [SUBMIT BOOKING] Failed to create contact person for property ${propertyId}:`, error);
							}
						}
					} else if (choice === "me") {
						// Use the current contact as contact person
						propertyContactPersonId = contactId;
					}
					
					// Set the appropriate contact_person field based on property index
					if (propertyContactPersonId) {
						// Map property index to correct contact_person field: 0->contact_person, 1->contact_person2, 2->contact_person3, 3->contact_person4
						const contactPersonField = propertyIndex === 0 ? 'contact_person' : `contact_person${propertyIndex + 1}`;
						dealUpdateData[contactPersonField] = String(propertyContactPersonId);
						console.log(`üîó [SUBMIT BOOKING] Updating deal ${dealId} with ${contactPersonField} for property ${propertyId} (index ${propertyIndex}): ${propertyContactPersonId}`);
					} else {
						console.warn(`‚ö†Ô∏è [SUBMIT BOOKING] No contact person ID determined for property ${propertyId} with choice "${choice}"`);
					}
				}
			} else {
				// For non-dilapidation inspections, use single contact_person field
				if (contactPersonId) {
					dealUpdateData.contact_person = String(contactPersonId);
					console.log(`üîó [SUBMIT BOOKING] Updating deal ${dealId} with contact_person: ${contactPersonId}`);
				} else {
					console.warn(`‚ö†Ô∏è [SUBMIT BOOKING] No contact person determined for deal ${dealId} - this may indicate an issue with the contact person selection logic`);
				}
			}
		} else {
			// For dilapidation inspections, contact person handling is done above in the dilapidation-specific section
			console.log(`üîó [SUBMIT BOOKING] Dilapidation inspection - contact person handling completed in dilapidation-specific section`);
		}
		
		// Update price information from deal_value (already set in quote step)
		try {
			const dealRes = await getRequest<{ data: { deal_value?: number } }>(`/items/os_deals/${encodeURIComponent(String(dealId))}?fields=deal_value`);
			const dealValue = (dealRes as any)?.data?.deal_value;
			if (dealValue && dealValue > 0) {
				dealUpdateData.deal_value = dealValue;
				console.log(`üí∞ [SUBMIT BOOKING] Deal ${dealId} already has deal_value: ${dealValue}`);
			} else {
				console.warn(`‚ö†Ô∏è [SUBMIT BOOKING] Deal ${dealId} has no deal_value set - this may indicate an issue with the quote step`);
			}
		} catch (error) {
			console.error(`‚ùå [SUBMIT BOOKING] Failed to load deal_value from deal ${dealId}:`, error);
		}
		
		// Apply updates if any
		if (Object.keys(dealUpdateData).length > 0) {
			console.log(`üîß [SUBMIT BOOKING] About to update deal ${dealId} with data:`, dealUpdateData);
			try {
				await patchRequest(`/items/os_deals/${encodeURIComponent(String(dealId))}`, dealUpdateData);
				console.log(`‚úÖ [SUBMIT BOOKING] Successfully updated deal ${dealId} with:`, dealUpdateData);
			} catch (error) {
				console.error(`‚ùå [SUBMIT BOOKING] Failed to update deal ${dealId}:`, error);
			}
		} else {
			console.warn(`‚ö†Ô∏è [SUBMIT BOOKING] No deal update data to apply for deal ${dealId}`);
		}
	}
	
	// Redirect to thank you page
	if (booking?.id != null) {
		console.log(`üîÑ [SUBMIT BOOKING] Redirecting to thank you page with booking ID: ${booking.id}`);
		const params = new URLSearchParams();
		params.set("bookingId", String(booking?.id));
		if (userId) params.set("userId", String(userId));
		if (contactId) params.set("contactId", String(contactId));
		if (dealId) params.set("dealId", String(dealId));
		if (propertyId) params.set("propertyId", String(propertyId));
		if (quoteId) params.set("quoteId", String(quoteId));
		if (invoiceId) params.set("invoiceId", String(invoiceId));
		
		console.log(`üîÑ [SUBMIT BOOKING] Redirect URL: /steps/09-thank-you?${params.toString()}`);
		redirect(`/steps/09-thank-you?${params.toString()}`);
	}
	
	return {
		success: true,
		message: "Booking submitted successfully",
		debug
	};
		
	} catch (error) {
		// Check if this is a Next.js redirect (which is expected behavior)
		if (error instanceof Error && error.message === "NEXT_REDIRECT") {
			// Re-throw redirect errors - they are handled by Next.js
			throw error;
		}
		
		console.error("üí• [SUBMIT BOOKING] Critical error:", error);
		debug.push({ tag: "critical_error", error: String(error) });
		return {
			success: false,
			message: "An unexpected error occurred",
			debug
		};
	}
}
